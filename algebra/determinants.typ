#import "../util.typ": *

== Определители

_Определение._ Пусть задана квадратная матрица $A = mat(a_11, ..., a_(1 n); dots.v, ..., dots.v; dots.v, ..., dots.v;a_(n 1), dots, a_(n n)) $. 
Её определитель это число, которое обозначают $ det A = mat(a_11, ..., a_(1 n); dots.v, ..., dots.v; dots.v, ..., dots.v;  a_(n 1), dots, a_(n n); delim: "|") $

По определению оно равно

$
  det A = sum_(sigma in S_n) a_(1, sigma(1)) dot a_(2, sigma(2)) dot ... dot a_(n, sigma(n)) dot op("sgn") (sigma)
$
Где сумма ведётся по всем перестановкам $sigma in S_n$.

=== Свойства определителя

Каждая квадратная $n times n$-матрица может рассматриваться как набор из $n$ $n$-мерных векторов:
$
  det A = det(A_1, A_2, ..., A_n)
$

Определитель обладает свойствами:
+ Аддитивность:
  $
    det(A_1, ..., A'_k + A''_k, ... A_n) = det(A_1, ..., A'_k, ... A_n) + \ + det(A_1, ..., A''_k, ..., A_n)
  $
  _Доказатательство._ $square$ Согласно определению определителя, 
  $
    det A = sum_((i_1, ..., i_n)) a_(1, i_1) dot ... dot a_(k, i_k) dot ... dot a_(n, i_n) dot op("sgn") (i_1, ..., i_n)
  $
  Но $k$-я строка распадается на сумму двух, поэтому $a_(k, i_k) = a'_(k, i_k) + a''_(k, i_k)$, ракскрыв скобки, получим две суммы:

  $
    det A = sum_((i_1, ..., i_n)) a_(1, i_1) dot ... dot a'_(k, i_k) dot ... dot a_(n, i_n) dot op("sgn") (i_1, ..., i_n) + \
    + sum_((i_1, ..., i_n)) a_(1, i_1) dot ... dot a''_(k, i_k) dot ... dot a_(n, i_n) dot op("sgn") (i_1, ..., i_n) = \ = det(A_1, ..., A'_k, ... A_n) + det(A_1, ..., A''_k, ..., A_n). space square.filled
  $

+ Однородность:

  $
    det(A_1, ..., lambda dot A_k , ... A_n) = lambda det(A_1, ..., A_k , ..., A_n)
  $
  _Доказатательство_ $square$ Левая часть равна:
  $
    sum_((i_1, ..., i_n)) a_(1, i_1) dot ... dot (lambda dot a_(k, i_k)) dot ... dot a_(n, i_n) dot op("sgn") (i_1, ..., i_n) = \ = lambda  sum_((i_1, ..., i_n)) a_(1, i_1) dot ... dot a_(k, i_k) dot ... dot a_(n, i_n) dot op("sgn") (i_1, ..., i_n) = lambda det A. space square.filled
  $

+ Кососимметричность:

  $
    det(A_1, ..., A_k , ..., A_l, ... A_n) = -det(A_1, ..., A_l , ..., A_k, ... A_n)
  $
  _Доказатательство._ $square$ Пусть матрица $A'$ получена из матрицы $A$ транспозицией двух строк с номерами $k$ и $l$. Переставим в произведениях $k$-е и $k$-е элементы:
  
  $
    det A = sum_(sigma in S_n) a_(1, sigma(1)) dot ... dot a_(k, sigma(k)) dot ... dot a_(l, sigma(l)) ... dot a_(n, sigma(n)) dot op("sgn") (sigma) = 

    \
    = sum_(sigma in S_n) a_(1, sigma(1)) dot ... dot a_(l, sigma(l)) dot ... dot a_(k, sigma(k)) ... dot a_(n, sigma(n)) dot op("sgn") (sigma)

  $
  Расммотрим перестановку $pi = sigma dot tau$, где $tau = (k, l)$ --- транспозиция $k$ и $l$. Она действует на все номера, кроме $k$ и $l$ так же, как и $sigma$, кроме того, $pi in S_n$, если $sigma in S_n$.

  $
    det A = sum_(pi in S_n) a'_(1, pi(1)) dot ... dot a'_(k, pi(k)) dot ... dot a'_(l, pi(l)) ... dot a'_(n, pi(n)) dot underbrace(op("sgn") (sigma), -op("sgn") (pi)) = -det A'.
  $
  $square.filled$

+ Определитель матрицы с нулевой строкой равен нулю:

  $
    exists k: A_k = 0 => det A = 0.
  $
  _Доказатательство._ $square$ 

  $
    det A = det(A_1, ..., A_k , ..., A_n) = det(A_1, ..., 0 dot A_k , ..., A_n) = \ =_("св. 2") 0 dot det(A_1, ..., A_k , ..., A_n) = 0. space square.filled
  $

+ Если в определителе 2 строки совпадают, то определитель равен нулю:

  $
    exists k != l: A_k = A_l => det A  = 0.
  $
  _Доказательство._ $square$ Переставим строки с местами $k$ и $l$ и воспользуемся кососимметричностью:
  $
    det A = det(A_1, ..., A_k , ..., A_l, ... A_n) = -det(A_1, ..., A_l , ..., A_k, ... A_n) = \ = - det A
  $
  Но $det A = - det A => det A = 0.$ $square.filled$

+ Если в определителе две строки пропорциональны, то он равен нулю:

  $
    exists k, l: k != l: A_l = lambda dot A_k => det A = 0
  $
  _Доказатательство._ $square$ 
  $
    det(A_1, ..., A_k , ..., A_l, ... A_n) = det(A_1, ..., A_k , ..., lambda dot A_k, ... A_n) = \ =
    lambda det(A_1, ..., A_k , ..., A_k, ... A_n) = 0. space square.filled
  $

+ Элементарные преобразования строк I типа не меняют определитель матрицы.

  _Доказатательство._ $square$ Пусть матрица $A'$ получена прибавлением $l$-й строки с коэфициентом $lambda$ к $k$-й строке матрицы $A$:
  $
    det A' = det(A_1, ..., A_k + lambda dot A_l, ..., A_l, ..., A_n) = \ =
    det(A_1, ..., A_k, ..., A_l, ..., A_n) + underbrace(det(A_1, ..., lambda dot A_l, ..., A_l, ..., A_n), =0 " по свойству 6") = \ = det A. space square.filled
  $

+ При транспонировании определитель матрицы не меняется:
  $
    det A = det A^T
  $
  _Доказательство._ $square$ Запишем по определению определитель транспонированной матрицы:

  $
    det A^T = sum_(sigma in S_n) a_(sigma(1), 1) dot ... dot a_(sigma(n), n) op("sgn") (sigma).
  $
  Пусть $pi = sigma^(-1)$. Тогда $sigma(j) = i => pi(i) = j$. Если $sigma$ пробегает все перестановки $S_n$ по одному разу, то и $pi$ пробегает все перестановки $S_n$ по одному разу. Кроме того, $op("sgn") (pi) = op("sgn") (sigma)$. 

  $
    det A^T = sum_(pi in S_n) a_(1, pi(1)) dot ... dot a_(n, pi(n)) dot underbrace(op("sgn"), op("sgn") (pi) ) (sigma) = det A. space square.filled
  $


+ Свойства 1-7 верны, если рассматривать определитель как функцию набора столбцов матрицы.

Из 1 и 2 свойства следует линейность определителя по любой строке, то есть определитель --- полилинейная кососимметричная функция строк матрицы. А из свойства 9 следует, что и от столбцов.

=== Вычисление определителя через приведение матрицы к треугольному виду

Мы можем привести элементарными преобразованиями строк любую квадратную матрицу $A$ к ступенчатому виду, получив матрицу $A*$, у которой ниже главной диагонали будут только нули:

$
  A arrow.long_("ЭП \n строк") A^* = mat(lambda_1, dots, dots, dots; 0, lambda_2, dots , dots; dots.v, dots, dots, dots;  0, 0, dots, lambda_n)
$
Если по пути было сделано $p$ перестановок строк и умножения строк производились на числа $mu_1, ..., mu_N$, то определитель исходной матрицы так связан с определителем ступенчатой матрицы:
$
  det A = det A^* dot (-1)^p dot mu_1 dot ... dot mu_N
$
=== Определитель треугольной матрицы

#theorem([_Предложение._ Определитель треугольной матрицы равен произведению элементов, стоящих на диагонали этой матрицы.
])
_Доказатательство._ $square$ Пусть у нас есть треугольная квадратная матрица $B$ с диагональю $mat(lambda_1, ..., lambda_n)$.

$
  det B = mat(lambda_1, dots, dots, dots; 0, lambda_2, dots , dots; dots.v, dots, dots, dots;  0, 0, dots, lambda_n; delim: "|")
$
Применим элементарное преобразование I типа: обнулим все элементы в $n$-м столбце выше единицы. 

$
  det B = lambda_n dot mat(lambda_1, dots, dots, 0; 0, lambda_2, dots , 0; dots.v, dots, dots, dots;  0, 0, dots, 1; delim: "|")
$
Теперь вынесем множитель $lambda_(n-1)$ из предпоследней строки.

$
  det B = lambda_n dot lambda_(n-1) mat(lambda_1, dots, dots, 0; 0, lambda_2, dots , dots; dots.v, dots, 1, 0;  0, 0, dots, 1; delim: "|")
$
Теперь с помощью элементарных преобразований I типа обнулим все элементы $(n-1)$-го столбца выше единицы.
Повторим эту процедуру до тех пор, пока на главной диагонали не останутся только единицы. Полученная матрица есть единичная.

$
  det B = lambda_1 dot ... dot lambda_n dot mat(1, dots, dots, 0; dots.v, 1, dots, 0; dots.v, dots, dots, dots; 0, dots, dots, 1; delim: "|")
$
Но в разложении определителя единичной матрицы только одно ненулевое произведение: $1 dot 1 dot ... dot 1 = 1$. Поэтому $det B = lambda_1 dot ... dot lambda_n$. $square.filled$


=== Определитель и другие кососимметричные полилинейные функции строк 

Мы установили, что
$
  det A = (-1)^p dot mu_1 dot ... dot mu_N dot lambda_1 dot ... dot lambda_n
$
где $p$ --- количество перестановок строк, а $mu_1, ..., mu_N$ --- множители, на которые умножались строки.

Если $f(A)$ --- любая кососимметричная полилинейная функция строк матрицы $A$, то аналогичными выкладками для неё можно получить 
$
  f(A) = (-1)^p dot mu_1 dot ... dot mu_N dot lambda_1 dot ... dot lambda_n dot f(E)
$
Поэтому функция $f$ отличается от $det$ лишь постоянным множителем.
$
  f(A) = f(E) dot det A
$

=== Разбиение матрицы на 4 блока
#emoji.book _Предложение._ Пусть матрицу $A$ можно разбить на 4 блока:
$
  A = mat(B, D; O, C)
$
причём $B in op("Mat")_k$, $C in op("Mat")_(n-k)$, $D in op("Mat")_(k, n-k)$, $O$ --- нулевая матрица.
Тогда 
$
  det A = det B dot det C
$
_Доказатательство._ $square$

+ Пусть матрица $A$ --- треугольная, $=> B, C$ --- тоже. Если $op("diag") B = (beta_1, ..., beta_k)$ и $op("diag") C = (gamma_(1), ... , gamma_(n-k))$, то 
  $
    det A = beta_1 dot ... dot beta_k dot gamma_1 dot ... dot gamma_(n-k) = det B dot det C
  $

+ В общем случае, мы можем привести $A$ к треугольному виду. Путём элементарных преобразований первых $k$ строк, так, чтобы $B'$ стала ступенчатой.
  $
    A arrow.long_("ЭП" k \ "строк") A' = mat(B', D'; O, C) arrow.long_("ЭП" (n-k) \ "строк") A'' = mat(B', D'; O, C')
  $
  При преобразованиях первых $k$ строк имеем
  $
    det A = det A' dot (-1)^p dot 1/mu_1 dot ... dot 1/mu_q
  $
  Если $r$ --- количество ЭП2, а $nu_i$ --- множители ЭП3, то 
  $
    det A' = det A'' dot (-1)^r dot 1/nu_1 dot ... dot 1/nu_s
  $
  Итак, соберём $det A$:
  $
    det A = det A'' dot (-1)^(p+r) dot 1/(mu_1 dot ... dot mu_q dot nu_1 dot ... dot nu_s)
  $
  Но матрица $A''$ треугольная, поэтому по доказанному в случае 1, имеем 
  $
    det A = det B' dot (-1)^p dot 1/(mu_1 dot ... dot mu_q) dot det C' dot (-1)^r dot 1/(nu_1 dot ... dot nu_s) = det B dot det C
  $
$square.filled$


=== Определитель Вандермонда 

_Определение._ Определителем Вандермонда называется определитель матрицы
$
  V(x_1, ..., x_n) = mat(delim: "|",
  1, 1, ..., 1;
  x_1, x_2, ..., x_n;
  x_1^2, x_2^2, ..., x_n^2;
  ..., ..., ..., ...;
  x_1^(n-1), x_2^(n-1), ..., x_n^(n-1)
  )
$

==== Вычисление определителя Вандермонда

Обнулим в первом столбце $V(x_1, ..., x_n)$ все элементы, кроме первого, вычитая из каждой строки предыдущую, умноженную на соответствующую степень $x_1$.

$
  V(x_1, ..., x_n) = mat(delim: "|",
  1, 1, ..., 1;
  0, x_2 - x_1, ..., x_n - x_1;
  0, x_2^2 - x_1 dot x_2, ..., x_n^2 - x_1 dot x_n;
  ..., ..., ..., ...;
  0, x_2^(n-1) - x_1 dot x_2^(n-2), ..., x_n^(n-1) - x_1 dot x_n^(n-2)
  )
$
Теперь, согласно предложению, мы можем разбить определитель на два блока, вынести множители по однородности определителя и получить рекурренту.
$
  V(x_1, ..., x_n) = 1 dot mat(delim: "|",
  x_2 - x_1, x_3 - x_1, ..., x_n - x_1;
  x_2^2 - x_1 dot x_2, x_3^2 - x_1 dot x_3, ..., x_n^2 - x_1 dot x_n;
  ... , ... , ..., ...;
  x_2^(n-1) - x_1 dot x_2^(n-2), x_3^(n-1) - x_1 dot x_3^(n-2), ..., x_n^(n-1) - x_1 dot x_n^(n-2)

  ) = \
  = (x_2 - x_1) dot ... dot (x_n - x_1) dot mat(delim: "|",
  1, 1, ..., 1;
  x_2, x_3, ..., x_n;
  ... , ... , ..., ...;
  x_2^(n-1), x_3^(n-1), ..., x_n^(n-1)
  )
  = \
  =
  (x_2 - x_1) dot ... dot (x_n - x_1) dot V(x_2, ..., x_n)
$

Рассуждая по индукции, будем иметь

$
  V(x_1, ..., x_n) = (x_2 - x_1) dot ... dot (x_n - x_(n-2)) dot mat(delim: "|", 1, 1; x_(n-1), x_n)
$
Итак, 
$
  V(x_1, ..., x_n) = product_(1 <= j < i <= n) (x_i - x_j)
$
==== Основное свойство определителя Вандермонда

В качестве следствия сразу получаем, что 

#theorem([

#emoji.book.red _Основное свойство определителя Вандермонда._ Определитель Вандермонда равен нулю тогда и только тогда, когда среди чисел $x_1, ..., x_n$ есть равные.

$
  V(x_1, ..., x_n) = 0 <=> exists i!=j: x_i = x_j
$
])

=== Критерий невырожденности матрицы 

#theorem([
#emoji.book.red _Теорема._ Квадратная матрица $A$ невырождена тогда и только тогда, когда $det A != 0$.
])
_Доказатательство._ $square$ Пусть $A in op("Mat")_n$. Приведём матрицу $A$ с помощью ЭП строк к треугольному виду, получив $A^*$. Так как ранг не меняется, то матрица $A$ невырождена $<=>$ матрица $A^*$ невырождена, то есть $op("rk") A^* = n$. А это случается если и только если в $op("diag") A^* = (lambda_1, ..., lambda_n)$ все $lambda_i$ отличны от нуля. Но так как $det A^* = lambda_1 dot ... dot lambda_n$, то $det A != 0$, так как эти два определителя пропорцианальны.
$square.filled$

=== Мультипликативное свойство определителя 

#theorem([
  #emoji.book.red _Теорема._ Пусть $A, B in op("Mat")_n$. Тогда
  $
    det(A dot B) = det(A) dot det(B)
  $
])

_Доказательство._ $square$ Рассмотрим два случая 

+ Если $A$ вырождена. Тогда $A dot B$ тоже вырождена, так как $op("rk") (A dot B) <= op("rk") A < n$. Аналогично, если $B$ вырождена.

+ Пусть обе матрицы невырождены. Каждую невырожденную матрицу можно представить в виде произведения элементарных матриц 
  $
    A = U_1 dot ... dot U_N
  $
  Тогда можно сказать, что $E -> A$ в ходе $N$ элементарных преобразований строк. Следовательно 
  $
    A dot B = U_1 dot ... dot U_N dot B
  $
  Значит матрица $A dot B$ получена с помощью _тех же_ ЭП строк из матрицы $B$. Тогда 
  $
    det A = lambda dot det E = lambda 
  $
  где $lambda$ --- коэффициент, получаемый при этих преобразованиях. Значит $det (A dot B) = lambda dot det B = det A dot det B$. $square.filled$

  === Миноры и вычисление определителей
#let csc = $circle.small$

  _Определение._ Выделим в матрице $A in op("Mat")_(m, n)$ квадратную подматрицу $k times k$ в строках с номерами $i_1, ..., i_k$ и столбцах с номерами $j_1, ..., j_k$.
  $
    A = mat(
      a_11, ..., ..., ..., a_(1n);
      dots.v, ..., ..., ..., dots.v;
      dots.v, csc, csc, csc, dots.v;
      dots.v, csc, csc, csc, dots.v;
      dots.v, csc, csc, csc, dots.v;
      a_(m 1), ..., ..., ..., a_(m n)
      
    )
  $

Определитель выделенной подматрицы называется минором порядка $k$ матрицы $A$.

$
  M^(j_1, ..., j_k)_(i_1, ..., i_k) = mat(delim: "|",
  a_(i_1, j_1), ..., a_(i_1, j_k);
  ..., ..., ...;
  a_(i_k, j_1), ..., a_(i_k, j_k)
  )
$

В частности, если $m = n$, рассмотрим миноры порядка $n - 1$.

_Определение._ Дополнительным минором к элементу $a_(i j)$ называется определитель матрицы, полученной вычёркиеванием $i$-й строки и $j$-го столбца матрицы $A$. Обозначается $M_(i j)$.

_Определение._ Алгебраическим дополнением к элементу $a_(i j)$ матрицы $A$ называется число
$
  A_(i j) = (-1)^(i + j) M_(i j)
$

#theorem([

#emoji.book.red. _Теорема._ Определитель матрицы $A$ равен сумме произведений элементов любой строки (столбца) на соответствующие алгебраические дополнения.
$
  det A = a_(i 1) dot A_(i 1) + ... + a_(i n) dot A_(i n)
$
$
  det A = a_(1 j) dot A_(1 j) + ... + a_(n j) dot A_(n j)
$
])

_Доказательство._ $square$ Докажем разложение по столбцу.

$
  A^((j)) = vec(a_(1 j), 0, dots.v, 0) + vec(0, a_(2 j), dots.v, 0) + ... + vec(0, 0, ..., a_(n j))
$
По аддитивности определителя имеем:
$
  det A = sum_(i=1)^n mat(delim: "|",
    a_11, ..., a_(1, (j-1)), 0, a_(1, (j+1)), ..., a_(1 n);
  ..., ..., ..., ..., ..., ...;
  a_(i 1), ..., a_(i, (j-1)), a_(i j), a_(i, (j+1)), ..., a_(i n);
  ..., ..., ..., ..., ..., ...;
  a_(n 1), ..., a_(n, (j-1)), 0, a_(n, (j+1)), ..., a_(n n);

  ) = 
  \
  =
  sum_(i=1)^n (-1)^(j -1) dot mat(delim: "|",
    0, a_11, ..., a_(1, (j-1)), a_(1, (j+1)), ..., a_(1 n);
  ..., ..., ..., ..., ..., ...;
  a_(i j), a_(i 1), ..., a_(i, (j-1)), a_(i, (j+1)), ..., a_(i n);
  ..., ..., ..., ..., ..., ...;
  0, a_(n 1), ..., a_(n, (j-1)), a_(n, (j+1)), ..., a_(n n);

  ) = \
  = sum_(i=1)^n
  (-1)^(i + j - 2) dot mat(delim: "|",
  a_(i j), a_(i 1), ..., a_(i, j-1), a_(i, j+1), ..., a_(i n);
  0, a_11, ..., a_(1, j-1), a_(1, j+1), ..., a_(1 n);
  ..., ..., ..., ..., ..., ..., ...;
  0, a_(n 1), ..., a_(n, (j-1)), a_(n, (j+1)), ..., a_(n n);
  ) = sum_(i=1)^n (-1)^(i + j) dot a_(i j) dot M_(i j)
$

Итак, для разложения по столбцам:
$
  det A = sum_(i=1)^n a_(i j) dot A_(i j)
$
Чтобы получить разложение по строкам, достаточно заметить, что 
$
  det A = det A^T = sum_(j=1)^n a_(j i)^T dot A_(j i)^T = sum_(i=1)^n a_(i j) dot A_(i j) space square.filled
$

=== Лемма о фальшивом разложении определителя 

#theorem([
#emoji.book.orange Пусть $i != j$, тогда 
$
  a_(i 1) dot A_(j 1) + ... + a_(i n) dot A_(j n) = 0
$
$
  a_(1 i) dot A_(1 j) + ... + a_(n i) dot A_(n j) = 0
$
])
_Доказатательство._ Рассмотрим матрицу, где вместо $j$ строки будет $i$-я строка той же матрицы $A$.

$
  det A' = mat(delim: "|",
    a_11, ..., a_(1 n);
    ..., ..., ...;
    a_(i 1), ..., a_(i n);
    ..., ..., ...;
    a_(i 1), ..., a_(i n);
    ..., ..., ...;
    a_(n 1), ..., a_(n n)
  ) = 0
$
Но если разложить его по $j$-й строке, то получим сумму:
$
  det A' = a_(i 1) dot A_(j 1) + ... + a_(i n) dot A_(j n) = 0
$
Аналогично доказывается для столбцов. $square.filled$

=== Формула обратной матрицы

_Определение._ Назовём присоединённой матрицей к квадратной матрице $A$, обозначаемой $A^or$ называется транспонированная матрица алгебраических дополнений матрицы $A$.

$
  A^or = mat(
    A_(1 1), A_(2 1), ..., A_(n 1);
    A_(1 2), A_(2 2), ..., A_(n 2);
    ..., ..., ..., ...;
    A_(1 n), A_(2 n), ..., A_(n n)
  )
$

Элементы $a_(i j)^or = A_(j i)$.


#theorem([
#emoji.book.red _Теорема._ Пусть матрица $A$ обратима. Тогда обратная матрица может быть вычислена по формуле

$
  A^(-1) = 1/(det A) dot A^or
$
])

_Доказатательство._ $square$ Рассмотрим $A dot A^or$: её элемент на месте $(i, j)$ равен

$
  a_(i 1) a_(1 j)^or + a_(i 2) a_(2 j)^or + ... + a_(i n) a_(n j)^or = a_(i 1) dot A_(j 1) + a_(i 2) dot A_(j 2) + ... + a_(i n) dot A_(j n)
$
Если $i = j$, то эта сумма равна $det A$, а при $i != j$, по лемме о фальшивом разложении определителя, она равна нулю. Поэтому 
$
  A dot A^or = mat(det A, 0, ..., 0;
    0, det A, ..., 0;
    ..., ..., ..., ...;
    0, 0, ..., det A
  ) = det A dot E
$
Аналогично, в порядке $A^or dot A$ для элемента на позиции $(i, j)$ имеем
$
  a_(i 1)^or dot a_(1 j) + a_(i 2)^or dot a_(2 j) + ... + a_(i n)^or dot a_(n j) = A_(1 i) dot a_(1 j) + A_(2 i) dot a_(2 j) + ... + A_(n i) dot a_(n j)
$
При $i = j$ это разложение $det A$ по столбцу $i$, а если $i != j$, по лемме о фальшивом разложении определителя, сумма равна нулю. Следовательно,
$
  A^or dot A = det A dot E
$
Если матрица $A$ обратима, то $det A != 0$, и мы получаем, что 
$
  A dot (1/(det A) dot A^or) = (1/(det A) dot A) dot A^or = E
$
что и означает требуемое.
$square.filled$

=== Метод Крамера решения СЛУ

Пусть у нас есть квадратная СЛУ 

$
  cases(
    a_11 x_1 + ... + a_1n x_n = b_1,
    dots.v space ................................ space dots.v,
    a_(n 1) x_1 + ... + a_(n n) x_n = b_n
  )
$
Её матричная запись будет 
$
  A dot x = b, 
$
где $A = mat(a_11, ..., a_1n;
  ..., ...., ...;
  a_(n 1), ..., a_(n n))$, $x = vec(x_1, ..., x_n)$, $b = vec(b_1, ..., b_n)$.

Обозначим $Delta = det A$. Обозначим $Delta_j$ определитель матрицы, которая получается заменой $j$-го столбца в матрице коэффициентов на столбец свободных членов($j=1,...,n$).

$
  Delta = mat(delim: "|",
    a_11, ..., a_1n;
    ..., ..., ...;
    a_(n 1), ..., a_(n n)
  )
$

$
  Delta_j = mat(delim: "|",
    a_11, ..., a_1(j-1), b_1, a_1(j+1), ..., a_1n;
    ..., ..., ..., ..., ..., ...;
    a_(n 1), ..., a_(n, (j-1)), b_n, a_(n, (j+1)), ..., a_(n n)
  )
$

#theorem([
#emoji.book.red _Правило крамера._ 
+ Квадратная СЛУ определена в том и только в том случае, когда $det A != 0$, причём 
  $
    x_j = Delta_j / Delta
  $
+ Если $Delta = 0$, но $exists j: space Delta_j != 0$, то СЛУ несовместна.
])
_Доказательство._ $square$ Заметим, что $A$ это матрица $n times n$, тогда как $accent(A, ~) = A | b$ это матрица $n times (n+1)$. Тогда 
$
  op("rk") A <= op("rk") accent(A, ~) <= n
$

+ Критерий определённости. Система линейных уравнений определена тогда и только тогда, когда $op("rk") A = op("rk") accent(A, ~) = n$ $<=> op("rk") A = n$ (последняя равносильность следует из неравенства выше). Значит это равносильно тому, что $A$ невырождена, что эквивалентно $Delta != 0$.

+ Условие несовместности. Пусть $Delta = 0$, но $exists j: space Delta_j != 0$. Отсюда следует, что столбцы матрицы $j$ линейно независимы. 
  $
    op("rk") {A^((1)), ..., A^((j-1)), b, A^((j+1)), ..., A^((n))} = n
  $
  При добавлении ещё одной строки ранг может только увеличиться:
  $
    op("rk") {A^((1)), ..., A^((j-1)), b, A^((j+1)), ..., A^((n))} <= op("rk") accent(A, ~)
  $
  Значит $op("rk") accent(A, ~) = n$ и $op("rk") A < n$, поэтому, по теореме Кронекера-Капелли, система несовместна.

+ Доказательство формул Крамера. Предположим, что $Delta != 0$. Значит у матрицы коэффициентов есть обратная: $A^(-1) = 1/(det A) dot A^or$. Если $A dot x = b$, то 
  $
    x = A^(-1) dot b = 1/(det A) dot A^or dot b
  $
  Распишем каждое неизвестное, $forall j=1,..,n$:
  $
    x_j = (a_(j 1)^or dot b_1 + a_(j 2)^or dot b_2 + ... + a_(j n)^or dot b_n) / 
    (det A) = (b_1 dot A_(1 j) + b_2 dot A_(2 j) + ... + b_n dot A_(n j)) / (det A) = Delta_j / Delta
  $
$square.filled$


