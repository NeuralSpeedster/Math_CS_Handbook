#import "../util.typ": *

== Определители

_Определение._ Пусть задана квадратная матрица $A = mat(a_11, ..., a_(1 n); dots.v, ..., dots.v; dots.v, ..., dots.v;a_(n 1), dots, a_(n n)) $. 
Её определитель это число, которое обозначают $ det A = mat(a_11, ..., a_(1 n); dots.v, ..., dots.v; dots.v, ..., dots.v;  a_(n 1), dots, a_(n n); delim: "|") $

По определению оно равно

$
  det A = sum_(sigma in S_n) a_(1, sigma(1)) dot a_(2, sigma(2)) dot ... dot a_(n, sigma(n)) dot op("sgn") (sigma)
$
Где сумма ведётся по всем перестановкам $sigma in S_n$.

=== Свойства определителя

Каждая квадратная $n times n$-матрица может рассматриваться как набор из $n$ $n$-мерных векторов:
$
  det A = det(A_1, A_2, ..., A_n)
$

Определитель обладает свойствами:
+ Аддитивность:
  $
    det(A_1, ..., A'_k + A''_k, ... A_n) = det(A_1, ..., A'_k, ... A_n) + \ + det(A_1, ..., A''_k, ..., A_n)
  $
  _Доказатательство._ $square$ Согласно определению определителя, 
  $
    det A = sum_((i_1, ..., i_n)) a_(1, i_1) dot ... dot a_(k, i_k) dot ... dot a_(n, i_n) dot op("sgn") (i_1, ..., i_n)
  $
  Но $k$-я строка распадается на сумму двух, поэтому $a_(k, i_k) = a'_(k, i_k) + a''_(k, i_k)$, ракскрыв скобки, получим две суммы:

  $
    det A = sum_((i_1, ..., i_n)) a_(1, i_1) dot ... dot a'_(k, i_k) dot ... dot a_(n, i_n) dot op("sgn") (i_1, ..., i_n) + \
    + sum_((i_1, ..., i_n)) a_(1, i_1) dot ... dot a''_(k, i_k) dot ... dot a_(n, i_n) dot op("sgn") (i_1, ..., i_n) = \ = det(A_1, ..., A'_k, ... A_n) + det(A_1, ..., A''_k, ..., A_n). space square.filled
  $

+ Однородность:

  $
    det(A_1, ..., lambda dot A_k , ... A_n) = lambda det(A_1, ..., A_k , ..., A_n)
  $
  _Доказатательство_ $square$ Левая часть равна:
  $
    sum_((i_1, ..., i_n)) a_(1, i_1) dot ... dot (lambda dot a_(k, i_k)) dot ... dot a_(n, i_n) dot op("sgn") (i_1, ..., i_n) = \ = lambda  sum_((i_1, ..., i_n)) a_(1, i_1) dot ... dot a_(k, i_k) dot ... dot a_(n, i_n) dot op("sgn") (i_1, ..., i_n) = lambda det A. space square.filled
  $

+ Кососимметричность:

  $
    det(A_1, ..., A_k , ..., A_l, ... A_n) = -det(A_1, ..., A_l , ..., A_k, ... A_n)
  $
  _Доказатательство._ $square$ Пусть матрица $A'$ получена из матрицы $A$ транспозицией двух строк с номерами $k$ и $l$. Переставим в произведениях $k$-е и $k$-е элементы:
  
  $
    det A = sum_(sigma in S_n) a_(1, sigma(1)) dot ... dot a_(k, sigma(k)) dot ... dot a_(l, sigma(l)) ... dot a_(n, sigma(n)) dot op("sgn") (sigma) = 

    \
    = sum_(sigma in S_n) a_(1, sigma(1)) dot ... dot a_(l, sigma(l)) dot ... dot a_(k, sigma(k)) ... dot a_(n, sigma(n)) dot op("sgn") (sigma)

  $
  Расммотрим перестановку $pi = sigma dot tau$, где $tau = (k, l)$ --- транспозиция $k$ и $l$. Она действует на все номера, кроме $k$ и $l$ так же, как и $sigma$, кроме того, $pi in S_n$, если $sigma in S_n$.

  $
    det A = sum_(pi in S_n) a'_(1, pi(1)) dot ... dot a'_(k, pi(k)) dot ... dot a'_(l, pi(l)) ... dot a'_(n, pi(n)) dot underbrace(op("sgn") (sigma), -op("sgn") (pi)) = -det A'.
  $
  $square.filled$

+ Определитель матрицы с нулевой строкой равен нулю:

  $
    exists k: A_k = 0 => det A = 0.
  $
  _Доказатательство._ $square$ 

  $
    det A = det(A_1, ..., A_k , ..., A_n) = det(A_1, ..., 0 dot A_k , ..., A_n) = \ =_("св. 2") 0 dot det(A_1, ..., A_k , ..., A_n) = 0. space square.filled
  $

+ Если в определителе 2 строки совпадают, то определитель равен нулю:

  $
    exists k != l: A_k = A_l => det A  = 0.
  $
  _Доказательство._ $square$ Переставим строки с местами $k$ и $l$ и воспользуемся кососимметричностью:
  $
    det A = det(A_1, ..., A_k , ..., A_l, ... A_n) = -det(A_1, ..., A_l , ..., A_k, ... A_n) = \ = - det A
  $
  Но $det A = - det A => det A = 0.$ $square.filled$

+ Если в определителе две строки пропорциональны, то он равен нулю:

  $
    exists k, l: k != l: A_l = lambda dot A_k => det A = 0
  $
  _Доказатательство._ $square$ 
  $
    det(A_1, ..., A_k , ..., A_l, ... A_n) = det(A_1, ..., A_k , ..., lambda dot A_k, ... A_n) = \ =
    lambda det(A_1, ..., A_k , ..., A_k, ... A_n) = 0. space square.filled
  $

+ Элементарные преобразования строк I типа не меняют определитель матрицы.

  _Доказатательство._ $square$ Пусть матрица $A'$ получена прибавлением $l$-й строки с коэфициентом $lambda$ к $k$-й строке матрицы $A$:
  $
    det A' = det(A_1, ..., A_k + lambda dot A_l, ..., A_l, ..., A_n) = \ =
    det(A_1, ..., A_k, ..., A_l, ..., A_n) + underbrace(det(A_1, ..., lambda dot A_l, ..., A_l, ..., A_n), =0 " по свойству 6") = \ = det A. space square.filled
  $

+ При транспонировании определитель матрицы не меняется:
  $
    det A = det A^T
  $
  _Доказательство._ $square$ Запишем по определению определитель транспонированной матрицы:

  $
    det A^T = sum_(sigma in S_n) a_(sigma(1), 1) dot ... dot a_(sigma(n), n) op("sgn") (sigma).
  $
  Пусть $pi = sigma^(-1)$. Тогда $sigma(j) = i => pi(i) = j$. Если $sigma$ пробегает все перестановки $S_n$ по одному разу, то и $pi$ пробегает все перестановки $S_n$ по одному разу. Кроме того, $op("sgn") (pi) = op("sgn") (sigma)$. 

  $
    det A^T = sum_(pi in S_n) a_(1, pi(1)) dot ... dot a_(n, pi(n)) dot underbrace(op("sgn"), op("sgn") (pi) ) (sigma) = det A. space square.filled
  $


+ Свойства 1-7 верны, если рассматривать определитель как функцию набора столбцов матрицы.

Из 1 и 2 свойства следует линейность определителя по любой строке, то есть определитель --- полилинейная кососимметричная функция строк матрицы. А из свойства 9 следует, что и от столбцов.

=== Вычисление определителя через приведение матрицы к треугольному виду

Мы можем привести элементарными преобразованиями строк любую квадратную матрицу $A$ к ступенчатому виду, получив матрицу $A*$, у которой ниже главной диагонали будут только нули:

$
  A arrow.long_("ЭП \n строк") A^* = mat(lambda_1, dots, dots, dots; 0, lambda_2, dots , dots; dots.v, dots, dots, dots;  0, 0, dots, lambda_n)
$
Если по пути было сделано $p$ перестановок строк и умножения строк производились на числа $mu_1, ..., mu_N$, то определитель исходной матрицы так связан с определителем ступенчатой матрицы:
$
  det A = det A^* dot (-1)^p dot mu_1 dot ... dot mu_N
$
=== Определитель треугольной матрицы

#theorem([_Предложение._ Определитель треугольной матрицы равен произведению элементов, стоящих на диагонали этой матрицы.
])
_Доказатательство._ $square$ Пусть у нас есть треугольная квадратная матрица $B$ с диагональю $mat(lambda_1, ..., lambda_n)$.

$
  det B = mat(lambda_1, dots, dots, dots; 0, lambda_2, dots , dots; dots.v, dots, dots, dots;  0, 0, dots, lambda_n; delim: "|")
$
Применим элементарное преобразование I типа: обнулим все элементы в $n$-м столбце выше единицы. 

$
  det B = lambda_n dot mat(lambda_1, dots, dots, 0; 0, lambda_2, dots , 0; dots.v, dots, dots, dots;  0, 0, dots, 1; delim: "|")
$
Теперь вынесем множитель $lambda_(n-1)$ из предпоследней строки.

$
  det B = lambda_n dot lambda_(n-1) mat(lambda_1, dots, dots, 0; 0, lambda_2, dots , dots; dots.v, dots, 1, 0;  0, 0, dots, 1; delim: "|")
$
Теперь с помощью элементарных преобразований I типа обнулим все элементы $(n-1)$-го столбца выше единицы.
Повторим эту процедуру до тех пор, пока на главной диагонали не останутся только единицы. Полученная матрица есть единичная.

$
  det B = lambda_1 dot ... dot lambda_n dot mat(1, dots, dots, 0; dots.v, 1, dots, 0; dots.v, dots, dots, dots; 0, dots, dots, 1; delim: "|")
$
Но в разложении определителя единичной матрицы только одно ненулевое произведение: $1 dot 1 dot ... dot 1 = 1$. Поэтому $det B = lambda_1 dot ... dot lambda_n$. $square.filled$


=== Определитель и другие кососимметричные полилинейные функции строк 

Мы установили, что
$
  det A = (-1)^p dot mu_1 dot ... dot mu_N dot lambda_1 dot ... dot lambda_n
$
где $p$ --- количество перестановок строк, а $mu_1, ..., mu_N$ --- множители, на которые умножались строки.

Если $f(A)$ --- любая кососимметричная полилинейная функция строк матрицы $A$, то аналогичными выкладками для неё можно получить 
$
  f(A) = (-1)^p dot mu_1 dot ... dot mu_N dot lambda_1 dot ... dot lambda_n dot f(E)
$
Поэтому функция $f$ отличается от $det$ лишь постоянным множителем.
$
  f(A) = f(E) dot det A
$

=== Разбиение матрицы на 4 блока
#emoji.book _Предложение._ Пусть матрицу $A$ можно разбить на 4 блока:
$
  A = mat(B, D; O, C)
$
причём $B in op("Mat")_k$, $C in op("Mat")_(n-k)$, $D in op("Mat")_(k, n-k)$, $O$ --- нулевая матрица.
Тогда 
$
  det A = det B dot det C
$
_Доказатательство._ $square$

+ Пусть матрица $A$ --- треугольная, $=> B, C$ --- тоже. Если $op("diag") B = (beta_1, ..., beta_k)$ и $op("diag") C = (gamma_(1), ... , gamma_(n-k))$, то 
  $
    det A = beta_1 dot ... dot beta_k dot gamma_1 dot ... dot gamma_(n-k) = det B dot det C
  $

+ В общем случае, мы можем привести $A$ к треугольному виду. Путём элементарных преобразований первых $k$ строк, так, чтобы $B'$ стала ступенчатой.
  $
    A arrow.long_("ЭП" k \ "строк") A' = mat(B', D'; O, C) arrow.long_("ЭП" (n-k) \ "строк") A'' = mat(B', D'; O, C')
  $
  При преобразованиях первых $k$ строк имеем
  $
    det A = det A' dot (-1)^p dot 1/mu_1 dot ... dot 1/mu_q
  $
  Если $r$ --- количество ЭП2, а $nu_i$ --- множители ЭП3, то 
  $
    det A' = det A'' dot (-1)^r dot 1/nu_1 dot ... dot 1/nu_s
  $
  Итак, соберём $det A$:
  $
    det A = det A'' dot (-1)^(p+r) dot 1/(mu_1 dot ... dot mu_q dot nu_1 dot ... dot nu_s)
  $
  Но матрица $A''$ треугольная, поэтому по доказанному в случае 1, имеем 
  $
    det A = det B' dot (-1)^p dot 1/(mu_1 dot ... dot mu_q) dot det C' dot (-1)^r dot 1/(nu_1 dot ... dot nu_s) = det B dot det C
  $
$square.filled$


=== Определитель Вандермонда 

_Определение._ Определителем Вандермонда называется определитель матрицы
$
  V(x_1, ..., x_n) = mat(delim: "|",
  1, 1, ..., 1;
  x_1, x_2, ..., x_n;
  x_1^2, x_2^2, ..., x_n^2;
  ..., ..., ..., ...;
  x_1^(n-1), x_2^(n-1), ..., x_n^(n-1)
  )
$

==== Вычисление определителя Вандермонда

Обнулим в первом столбце $V(x_1, ..., x_n)$ все элементы, кроме первого, вычитая из каждой строки предыдущую, умноженную на соответствующую степень $x_1$.

$
  V(x_1, ..., x_n) = mat(delim: "|",
  1, 1, ..., 1;
  0, x_2 - x_1, ..., x_n - x_1;
  0, x_2^2 - x_1 dot x_2, ..., x_n^2 - x_1 dot x_n;
  ..., ..., ..., ...;
  0, x_2^(n-1) - x_1 dot x_2^(n-2), ..., x_n^(n-1) - x_1 dot x_n^(n-2)
  )
$
Теперь, согласно предложению, мы можем разбить определитель на два блока, вынести множители по однородности определителя и получить рекурренту.
$
  V(x_1, ..., x_n) = 1 dot mat(delim: "|",
  x_2 - x_1, x_3 - x_1, ..., x_n - x_1;
  x_2^2 - x_1 dot x_2, x_3^2 - x_1 dot x_3, ..., x_n^2 - x_1 dot x_n;
  ... , ... , ..., ...;
  x_2^(n-1) - x_1 dot x_2^(n-2), x_3^(n-1) - x_1 dot x_3^(n-2), ..., x_n^(n-1) - x_1 dot x_n^(n-2)

  ) = \
  = (x_2 - x_1) dot ... dot (x_n - x_1) dot mat(delim: "|",
  1, 1, ..., 1;
  x_2, x_3, ..., x_n;
  ... , ... , ..., ...;
  x_2^(n-1), x_3^(n-1), ..., x_n^(n-1)
  )
  = \
  =
  (x_2 - x_1) dot ... dot (x_n - x_1) dot V(x_2, ..., x_n)
$

Рассуждая по индукции, будем иметь

$
  V(x_1, ..., x_n) = (x_2 - x_1) dot ... dot (x_n - x_(n-2)) dot mat(delim: "|", 1, 1; x_(n-1), x_n)
$
Итак, 
$
  V(x_1, ..., x_n) = product_(1 <= j < i <= n) (x_i - x_j)
$
==== Основное свойство определителя Вандермонда

В качестве следствия сразу получаем, что 

#theorem([

#emoji.book.red _Основное свойство определителя Вандермонда._ Определитель Вандермонда равен нулю тогда и только тогда, когда среди чисел $x_1, ..., x_n$ есть равные.

$
  V(x_1, ..., x_n) = 0 <=> exists i!=j: x_i = x_j
$
])

=== Критерий невырожденности матрицы 

#theorem([
#emoji.book.red _Теорема._ Квадратная матрица $A$ невырождена тогда и только тогда, когда $det A != 0$.
])
_Доказатательство._ $square$ Пусть $A in op("Mat")_n$. Приведём матрицу $A$ с помощью ЭП строк к треугольному виду, получив $A^*$. Так как ранг не меняется, то матрица $A$ невырождена $<=>$ матрица $A^*$ невырождена, то есть $op("rk") A^* = n$. А это случается если и только если в $op("diag") A^* = (lambda_1, ..., lambda_n)$ все $lambda_i$ отличны от нуля. Но так как $det A^* = lambda_1 dot ... dot lambda_n$, то $det A != 0$, так как эти два определителя пропорцианальны.
$square.filled$

=== Мультипликативное свойство определителя 

#theorem([
  #emoji.book.red _Теорема._ Пусть $A, B in op("Mat")_n$. Тогда
  $
    det(A dot B) = det(A) dot det(B)
  $
])

_Доказательство._ $square$ Рассмотрим два случая 

+ Если $A$ вырождена. Тогда $A dot B$ тоже вырождена, так как $op("rk") (A dot B) <= op("rk") A < n$. Аналогично, если $B$ вырождена.

+ Пусть обе матрицы невырождены. Каждую невырожденную матрицу можно представить в виде произведения элементарных матриц 
  $
    A = U_1 dot ... dot U_N
  $
  Тогда можно сказать, что $E -> A$ в ходе $N$ элементарных преобразований строк. Следовательно 
  $
    A dot B = U_1 dot ... dot U_N dot B
  $
  Значит матрица $A dot B$ получена с помощью _тех же_ ЭП строк из матрицы $B$. Тогда 
  $
    det A = lambda dot det E = lambda 
  $
  где $lambda$ --- коэффициент, получаемый при этих преобразованиях. Значит $det (A dot B) = lambda dot det B = det A dot det B$. $square.filled$

  === Миноры и вычисление определителей
#let csc = $circle.small$

  _Определение._ Выделим в матрице $A in op("Mat")_(m, n)$ квадратную подматрицу $k times k$ в строках с номерами $i_1, ..., i_k$ и столбцах с номерами $j_1, ..., j_k$.
  $
    A = mat(
      a_11, ..., ..., ..., a_(1n);
      dots.v, ..., ..., ..., dots.v;
      dots.v, csc, csc, csc, dots.v;
      dots.v, csc, csc, csc, dots.v;
      dots.v, csc, csc, csc, dots.v;
      a_(m 1), ..., ..., ..., a_(m n)
      
    )
  $

Определитель выделенной подматрицы называется минором порядка $k$ матрицы $A$.

$
  M^(j_1, ..., j_k)_(i_1, ..., i_k) = mat(delim: "|",
  a_(i_1, j_1), ..., a_(i_1, j_k);
  ..., ..., ...;
  a_(i_k, j_1), ..., a_(i_k, j_k)
  )
$

В частности, если $m = n$, рассмотрим миноры порядка $n - 1$.

_Определение._ Дополнительным минором к элементу $a_(i j)$ называется определитель матрицы, полученной вычёркиеванием $i$-й строки и $j$-го столбца матрицы $A$. Обозначается $M_(i j)$.

_Определение._ Алгебраическим дополнением к элементу $a_(i j)$ матрицы $A$ называется число
$
  A_(i j) = (-1)^(i + j) M_(i j)
$

#theorem([

#emoji.book.red. _Теорема._ Определитель матрицы $A$ равен сумме произведений элементов любой строки (столбца) на соответствующие алгебраические дополнения.
$
  det A = a_(i 1) dot A_(i 1) + ... + a_(i n) dot A_(i n)
$
$
  det A = a_(1 j) dot A_(1 j) + ... + a_(n j) dot A_(n j)
$
])

_Доказательство._ $square$ Докажем разложение по столбцу.


$square.filled$
