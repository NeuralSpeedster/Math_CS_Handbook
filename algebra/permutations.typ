#import "../util.typ": *

== Перестановки

_Определение._ Пусть $Omega$ - конечное множество из $n$ элементов. Удобно считать, что $Omega = {1, 2, ..., n}$. Зададим множество всех биективных преобразований $Omega -> Omega$:
$ S = S_n (Omega) = {sigma: Omega -> Omega | sigma - "биективно" } $ 

Элементы множества $S$ называются _перестановками_(или _подстановками_) множества $Omega$.

Развёрнутая запись перестановки $pi: i -> pi(i) space forall i = 1, 2,..., n$ имеет вид:

$ mat(1, 2, ..., n; pi(1), pi(2), ..., pi(n)) $

Её также называют стандартной двухрядной.

_Определение._ Перестановка $ e = mat(1, 2, ..., n; 1, 2, ..., n) $ называется _единичной перестановкой_.

=== Умножение перестановок 

Пусть $pi, sigma in S$. Тогда их произведение $pi sigma$ находится из общего определения композиции преобразований. $forall i=1, ..., n$:

$ (pi  sigma)(i) = pi(sigma(i)) $

Пусть, например, $pi = mat(1, 2, 3, 4; 2, 3, 4, 1)$ и $sigma = mat(1, 2, 3, 4; 4, 3, 2, 1)$. Тогда:

$ (pi  sigma)(1) = pi(sigma(1)) = pi(4) = 1 $
$ (pi  sigma)(2) = pi(sigma(2)) = pi(3) = 4 $
$ (pi  sigma)(3) = pi(sigma(3)) = pi(2) = 3 $
$ (pi  sigma)(4) = pi(sigma(4)) = pi(1) = 2 $

Таким образом, $pi  sigma = mat(1, 2, 3, 4; 1, 4, 3, 2)$. Имеем:

$ mat(1, 2, 3, 4; 4, 3, 2, 1) mat(1, 2, 3, 4; 2, 3, 4, 1) = mat(1, 2, 3, 4; 3, 2, 1, 4) $

==== Свойства произведения перестановок
Свойства произведения перестановок.

+ Ассоциативность: $forall alpha, beta, gamma in S_n: alpha (beta gamma) = (alpha beta) gamma$.

+ Единичный элемент: $exists e in S_n: forall alpha in S_n alpha e = e alpha $.

+ Обратная перестановка: $forall alpha in S_n space exists alpha^(-1) in S_n: alpha alpha^(-1) = alpha^(-1) alpha = e$.

  Действительно, можно для $alpha$ поменять местами строки:
  $
  alpha = mat(i_1, i_2, ..., i_n; j_1, j_2, ..., j_n)
  $
  $
     alpha^(-1) = mat(j_1, j_2, ..., j_n; i_1, i_2, ..., i_n).
  $
+ Некоммутативность. Вообще говоря, для $alpha, beta in S_n$: $alpha beta eq.not beta alpha$.

=== Количество перестановок
Мощность множества перестановок равна факториалу количества элементов $Omega$. 
Действительно, для каждого из $n$ элементов множества $Omega$ можно выбрать одно из $n$ мест, затем для оставшихся $n-1$ элементов — одно из $n-1$ мест и так далее(согласно правилу произведения). В итоге получаем:

$ abs(S_n) = n (n-1) (n-2) ... 1 = n! $<perm_count>

=== Циклы

_Определение._ _Циклом длины $l<=n$_ называется такая перестановка $sigma in S_n$, что $sigma(i_j) = (i_(j+1))$ $forall j = 1, 2, ..., (l-1)$ и $sigma(l) = i_1$, а все элементы, не указанные перечислением, остаются на своих местах.

Однорядная запись цикла:
$
  (i_1, i_2, ..., i_l)
$
_Определение._ _Орбитой_ цикла называется множество элементов, которые участвуют в цикле: ${i_1, i_2, ..., i_l}$.

_Определение._ Два цикла $sigma = (i_1, i_2, ..., i_l)$ и $tau = (j_1, j_2, ..., j_m)$ называются _независимыми_, если ${i_1, i_2, ..., i_l} inter {j_1, j_2, ..., j_m} = empty$.

Независимые циклы коммутативны: $sigma pi = pi sigma$.

=== Степень перестановки
Пусть $pi in S_n$. Тогда перестановка, равная $pi$ в степени $s in ZZ$ определяется так:

$ pi^s = cases(delim: "{",
pi (pi^(s-1)) comma space "если" space s > 0, 
e comma space "если" space s = 0, 
(pi^(-1))^(-s) comma space "если" space s < 0
) $

Свойства возведения в степень перестановок:
+ $forall sigma in S_n, forall k, l in ZZ:$ $sigma^k sigma^l = sigma^(k + l) $
+ $(sigma^k)^l = sigma^(k dot l) $

=== Орбита элемента
_Определение._ _Орбитой числа_ $i in {1, ..., n}$ под действием $sigma$ называется множество
$
  O(i) =_"def" {sigma^k | k in ZZ}
$
Среди элементов орбиты числа обязаны быть повторения:
$
  exists k, l in ZZ, k > l: sigma^k (i) = sigma^l (i)
$
Применим $sigma^(-l)$:
$
  sigma^(k - l) (i) = sigma^0 (i) = i
$
Итак, существует положительная степень $k - l > 0$, такая, что перестановка $sigma$ в степени $k - l$ возвращает элемент на место. Тогда среди показателей положительных степеней можно выбрать наименьший.
$
  m = min_(p in NN) {p | sigma^p (i) = i}
$
Тогда для всех степеней, меньших $m$, орбита зацикливается и состоит всего из $m$ чисел:
$
  O(i) = {i, sigma(i), sigma^2(i), ..., sigma^{m-1}(i)}.
$

==== Свойства орбит элементов

+ Разные орбиты не пересекаются: $O(i) inter O(j) = empty$, если $i != j$.

  _Доказательство:_ $square$ Пусть $O(i) inter O(j) != empty$, тогда в пересечении этих орбит есть некоторое число $k$: $k in O(i) inter O(j)$, получим:
  $
    k = sigma^p (i) = sigma^q (j)
  $
  Если к левой и правой части равенства применить $sigma^(-p)$, то получим:
  $
    i = sigma^(q - p) (j)
  $
  Теперь мы можем получить, что любой элемент орбиты $i$ лежит в $O(j)$, а именно $forall l in ZZ:$
  $
    sigma^l (i) = sigma^(l + q - p) (j) in O(j)
  $
  Итак, $
          O(i) subset.eq O(j)
        $
  Аналогично, меняя $i$ и $j$, местами, получаем:
  $
    O(j) subset.eq O(i)
  $
  Но это в точности означает, что $O(i) = O(j)$. Значит, если две орбиты пересекаются, то они совпадают.
  $square.filled$
  
+ Орбиты образуют разбиение множества чисел ${1, ..., n}$ на попарно непересекающиеся подмножества.

  _Доказательство:_ $square$ Действительно, каждое число лежит в какой-то орбите, например, в своей. $square.filled$

=== Теорема о разложении перестановки в произведение независимых циклов
#theorem([
_Теорема._ Любая перестановка $sigma in S_n$ может быть представлена в виде произведения попарно независимых циклов:
$
  sigma = sigma_1 dot sigma_2 dot ... dot sigma_s,
$
Причём это разложение единственно с точностью до порядка множителей.
])
_Доказательство:_ $square$
Запишем разбиение множества $Omega = {1, ..., n}$ на непересекающиеся орбиты:
$
  Omega = underbrace(O_1 union O_2 union ... union O_s, "орбиты, в которых \n > 1 элемента") union underbrace(O_(s+1) union ... union O_t, "единичные орбиты \n(если есть)"),
$
При действии перестановки $sigma in S_n$ элементы обязательно перемещаются внутри своих орбит. 
//  TODO: добавить схему 

Каждой орбите соответствует цикл, причём эти циклы независимы в силу того, что орбиты непересекающиеся. Тогда перестановка $sigma$ записывается в виде произведения:
$
  sigma = (i_1, i_2, ..., i_l) dot (j_1, j_2, ..., j_m) dot ... dot (k_1, k_2, ..., k_p)
$
Мы доказали существование разложения на независимые циклы. Докажем единственность. Пусть перестановка $sigma$ разложена в произведение попарно независимых циклов:
$
  sigma = sigma_1 dot sigma_2 dot ... dot sigma_s,
$
где $sigma_1 = (i_1, i_2, ..., i_l)$, $sigma_2 = (j_1, j_2, ..., j_m)$, ..., $sigma_s = (k_1, k_2, ..., k_p)$. Из схемы действия $sigma$ видно, что орбиты перестановки $sigma$ на $Omega$ это орбиты $sigma_1$, $sigma_2$, ..., $sigma_s$ и оставшиеся неподвижные точки. 

Таким образом, по $sigma$ можно однозначно восстановить орбиты циклов $sigma_1$, $sigma_2$, ..., $sigma_s$. А из них можно восстановить и сами циклы $sigma_i$, потому что на своей орбите $sigma_i$ действует так же, как и сама $sigma$. Что и требовалось доказать. $square.filled$

=== Транспозиции

_Определение._ _Транспозицией_ называется цикл длины 2. Записывается как $tau = mat(i, j)$, где $i$ и $j$ — элементы, которые меняются местами. 


#theorem([
_Предложение._ Любая перестановка может быть разложена в произведение транспозиций.])

_Доказательство:_ $square$ Разложим перестановку $sigma in S_n$ в произведение попарно независимых циклов:
$
  sigma = sigma_1 dot sigma_2 ... dot sigma_s
$
Достаточно показать, что любой цикл можно разложить в произведение транспозиций. Пусть цикл $sigma_i$ выглядит так:
$
  sigma_i = (i_1, i_2, ... i_l)
$
Тогда такой цикл можно записать как произведение цикла длины $(l-1)$ и транспозиции двух последних номеров в орбите этого цикла:
$
  sigma_i = (i_1, i_2, ... i_(l-1)) dot (i_(l-1), i_l)
$
Аналогино, можно разложить цикл длины $(l-1)$ в произведение цикла длины $(l - 2)$ и транспозиции двух последних элементов. Продолжая далее этот алгоритм, мы дойдём до того, что в произведении останутся только транспозиции. Что и требовалось доказать. $square.filled$

=== Инверсии и знак перестановки

_Определение._ Назовём _инверсией(беспорядком)_ в перестановке $mat(1, 2, ..., n; i_1, i_2, ..., i_n)$ пару $(i_k, i_l)$, где $k < l$, но $i_k > i_l$.

_Определение._ Перестановка чётна, если количество инверсий в ней чётно.

_Определение._ Перестановка нечётна, если количество инверсий в ней нечётно.

_Определение._ Знаком перестановки $sigma$ называется число
$
  op("sgn")(sigma) = cases(1 ", если " sigma " чётна", 
  -1 ", если " sigma " нечётна"
  )
$

#theorem([_Предложение._ При транспозиции двух элементов перестановки её чётность меняется.])

_Доказательство._ $square$ Пусть мы поменяли местами $i_k$ и $i_l$.
+ Среди пар $(i_p, i_q)$, где $p, q in.not {k, l}$, количество инверсий не меняется.
+ Среди пар $(i_p, i_k)$, где $p < k or p > l$ не меняется.
+ Среди пар $(i_p, i_l)$, где $p < k or p > l$ тоже не меняется.
+ Среди пар $(i_q, i_k)$, где $k < q < l$, количество инверсий меняется на $plus.minus 1 plus.minus 1 plus.minus ... plus.minus plus.minus 1$, таких пар $l - k - 1$.

+ Среди пар $(i_q, i_l)$, где $k < q < l$, количество инверсий меняется на $plus.minus 1 plus.minus 1 plus.minus ... plus.minus plus.minus 1$, таких пар $l - k - 1$.

+ В паре $(i_k, i_l)$ инверсия либо появляется, либо исчезает.

Общее изменение количества инверсий равно $2 (l - k - 1) + 1 eq.triple 1 (mod 2)$, поэтому чётность перестановки изменилась. $square.filled$

#theorem([_Следствие._ Количество чётных и нечётных перестановок в $S_n$ одинаково и равно $n!/2$.])

_Доказательство._ $square$ Установим взаимно однозначное соответствие между чётными и нечётными перестановками. Для этого рассмотрим чётную перестановку $sigma in S_n$:
$
  sigma = mat(1, 2, ..., n; i_1, i_2, ..., i_n) arrow.long_(i_1 <->i_2) mat(1, 2, ..., n; i_2, i_1, ..., i_n)
$
Следовательно, чётных и нечётных поровну.
$square.filled$


#theorem([
  _Предложение._ Если перестановка $sigma$ разложена в произведение $N$ транспозиций, то можно найти её знак.
  $
    sigma = tau_1 dot tau_2 ... dot tau_N => op("sgn") (sigma) = (-1)^N
  $
])

_Доказатательство._ $square$ Проведём индукцию по числу множителей.
+ База: $N = 0$. $sigma = e => op("sgn") (sigma) = 1$ --- верно.

+ Шаг. Пусть 
$
  sigma = tau_1 dot tau_2 ... dot tau_(N-1) dot tau_N
$
Обозначим $sigma' = tau_1 dot tau_2 ... dot tau_(N-1)$. Пусть $tau_N = (k, l)$. Действие $sigma'$ на все числа, кроме $k$ и $l$, такое же, как у $sigma$. Для $k$ и $l$ под дейтсвием $sigma$ получаем:
$
  k -> l -> i_l
$
$
  l -> k -> i_K
$
Но $sigma'$ действует так: $k -> i_k$, $l -> i_l$, значит перестановки $sigma$ и $sigma'$ отличаются транспозиицей $i_k$ и $i_l$, а значит их знаки различны по доказанному выше предложению.
$
  op("sgn") (sigma) = - op("sgn") (sigma') =_("предп. \nинд.") -(-1)^(N-1) = (-1)^N.
$
Переход доказан и вместе с ним и утверждение $forall N in NN$. $square.filled$


#theorem([
  _Предложение._ Мультипликативное свойство знака:
  $
    op("sgn") (sigma dot sigma') = op("sgn") (sigma) dot op("sgn") (sigma')
  $
])
_Доказатательство._ $square$ Пусть перестановки $sigma$ и $sigma'$ разложены на транспозиции:
$
  sigma = tau_1 dot tau_2 dot ... dot tau_k
$
$
  sigma' = pi_1 dot pi_2 dot ... dot pi_s.
$
Тогда, напрямую умножив их, получим
$
  op("sgn") (sigma sigma') = op("sgn") (tau_1 dot tau_2 dot ... dot tau_k dot pi_1 dot pi_2 dot ... dot pi_s) = 
  \ = (-1)^(k + s) = (-1)^k dot (-1)^s =  op("sgn") (sigma) dot op("sgn") (sigma'). 
$
$square.filled$


#theorem([
  _Предложение._ Знак обратной перестановки:
  $
    op("sgn") (sigma^(-1)) = op("sgn") (sigma)
  $
])
_Доказатательство._ $square$ Согласно мультипликативности знака перестановки получаем:
$
  op("sgn") (e) = op("sgn") (sigma dot sigma') = op("sgn") (sigma) dot op("sgn") (sigma')
$
Но $op("sgn") (e) = 1$, поэтому
$
  op("sgn") (sigma) dot op("sgn") (sigma') = 1 => op("sgn") (sigma) = op("sgn") (sigma').
$
Что и требовалось доказать. $square.filled$