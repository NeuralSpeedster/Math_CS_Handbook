== Динамическое программирование

Динамическое программирование(ДП) позволяет решать задачи, комбинируя решения вспомогательных задач.

Два варианта задач для решения методом динамического программирования:
- подсчёт количества способов;
- оптимизация(максимум или минимум).

*Этапы решения задачи методом ДП*.
+ Описание структуры оптимального решения;
+ Реккурентное соотношение для значения, соответствующего оптимальному решению(включая базу динамики);
+ Вычисление значения, соответствующего оптимальному решению методом восходящего анализа.
+ Составление оптимального решения, полученного на предыдущих этапах.

=== Простые примеры ДП

==== Ступеньки

За один шаг можно подняться на одну или две ступеньки. За посещение каждой из ступенек дают $a_i$ рублей. Необходимо найти максимальную сумму за подъём на вершину лестницы из $n$ ступенек.

_Решение:_  Пусть $d p [i]$ - максимальная сумма за подъём на $i$-ю ступеньку. Тогда 
$ d p [i] = a[i] + max(d p [i-1], d p [i-2]) $

База динамики. $d p [0] = 0$, $d p [1] = a[1]$. Ответ: $d p[n] space square.filled$.

Полученное решение имеет временную и пространственную сложность $Theta(n)$.
Пример таблицы для данной задачи(0 добавлен в качестве нулевого элемента).
#align(center, 
table(rows: 2, columns: 10, align: center,
$a[i]$, $0$, $10$, $-5$, $-20$, $-10$, $20$, $30$, $-10$, $10$, 
$d p[i]$, $0$, $10$, $5$, $-10$, $-5$, $15$, $45$, $35$, $55$, 
))

==== Ступеньки с сертификатом 

За один шаг можно подняться на одну или две ступеньки. За посещение каждой из ступенек дают $a_i$ рублей. Необходимо найти максимальную сумму за подъём на вершину лестницы из $n$ ступенек. Вывести _номера ступенек_, по которым мы шагали.

_Решение:_  Пусть $d p [i]$ - максимальная сумма за подъём на $i$-ю ступеньку. Выделим массив $p r e v [n]$, в $i$-том элементе которого будем хранить номер ступепньки, с которой мы попали на $i$-ю ступеньку. Тогда
$ d p [i] = a[i] + max(d p [i-1], d p [i-2]) $
$ p r e v[i] = op("argmax", limits: #true)_(i) (d p [i-1], d p [i-2]) $

База динамики. $d p [0] = 0$, $d p [1] = a[1]$ и теперь добавляется $p r e v[1] = 0$. Ответ: $d p[n] space square.filled$.

Пример таблицы для данной задачи:
#align(center, 
table(rows: 3, columns: 10, align: center,
$a[i]$, $0$, $10$, $-5$, $-20$, $-10$, $20$, $30$, $-10$, $10$, 
$d p[i]$, $0$, $10$, $5$, $-10$, $-5$, $15$, $45$, $35$, $55$, 
$p r e v[i]$, $0$, $0$, $1$, $1$, $2$, $4$, $5$, $6$, $6$, 
))

==== Наибольшая возрастающая подпоследовательность
Задача: найти длину наибольшей возрастающей подпоследовательности в массиве $a$.

- _подпоследовательность_ --- подпоследовательность, полученная вычёркиванием некоторых элементов из исходной(необязательно подряд идущих);

- _возрастающая_ --- $forall i in overline(1..n): a_(i+1) > a_i$.

- _наибольшая_ --- максимальная по длине среди всех подходящих 
  подпоследовательностей.


_Решение._ Пусть $d p [i]$ - длина наибольшей возрастающей подпоследовательности, заканчивающейся на $i$-ом элементе. Будем
для очереднего элемента $a[i]$ запускать внутренний цикл на отрезке от $0$ до $i-1$ и проверять, можно ли продлить возрастающую подпоследовательность элементом $a[i]$. Если да, то берём максимум из всех подходящих $d p[j] space (j < i)$. Если нет, то записываем $p r e v[i] = -1$ и $a[i] = 1$. Ответ на задачу: $max(d p[i])$.

К сожалению, временная сложность этого решения $Theta(n^2)$. Пример таблицы ниже. Жёлтым выделены индексы НВП, зелёным максимум динамики(ответ), а красным те элементы, у которых нет предшественников.

#align(center, 
table(rows: 3, columns: 8, align: center,
table.header([индекс], table.cell($0$, fill: rgb("#f7f744")), table.cell($1$, fill: rgb("#f7f744")), [2], table.cell($3$, fill: rgb("#f7f744")), [4], table.cell($5$, fill: rgb("#f7f744")), [6]),

$a[i]$, $4$, $10$, $5$, $12$, $3$, $24$, $7$, 
$d p[i]$, $1$, $2$, $2$, $3$, $1$, table.cell($4$, fill: lime), $3$, 
$p r e v[i]$, table.cell($-1$, fill: red), $0$, $0$, $1$, table.cell($-1$, fill: red), $3$, $2$,
))
Приведём решение за $O(n log n)$. //TODO: добавить ссылку на сорт+ бинпоиск 
==== Покупка билетов

В очереди за билетами стоит $n$ людей. $i-й$ человек может купить себе билет за $A_i$ секунд. Себе и следующему за $B_i$ секунд. Себе, следующему и ещё одному за ним за $C_i$ секунд.
Найти минимальное время, за которое все люди будут с билетами.

_Решение._ Пусть $d p [i]$ - минимальное время обилечивания 
первых $i$ людей. Тогда реккурентное соотношение будет иметь вид:

$ d p[i] = max(d p [i-1] + A_i, \ d p [i-2] + B_i, \ d p [i-3] + C_i) $

В качестве базы динамики запишем 3 виртуальных человека с бесконечным временем покупки, чтобы начинать использовать реккуренту с $n=1$ и определим для них динамику, равную 0. Сложность решения по времени равна $Theta(n)$.

Пример таблицы для этой задачи ниже.
#align(center, 
table(rows: 9, columns: 5, align: center,  
[№], $A_i$, $B_i$, $C_i$, $d p [i]$,

[-2], $infinity$, $infinity$, $infinity$, $0$,

[-1], $infinity$, $infinity$, $infinity$, $0$,

[0], $infinity$, $infinity$, $infinity$, $0$,

[1], [5], [10], [15], [5],

[2], [2], [10], [15], [7],

[3], [5], [5], [5], [12],

[4], [20], [20], [1], [12],

[5], [20], [1], [1], [12],
))

==== Представление числа минимальной последовательностью операций

Дано целое число $N <= 10^4$. Представить его в виде арифметического выражения _миинимальной длины_, в котором 
используются только операции сложения, умножения и скобки, а все числа не превосходят $K$.

_Решение._ Пусть $d p [i]$ - минимальная длина арифметического выражения для числа $i$.

 === Двумерное динамическое программирование

==== Наибольшая общая подпоследовательность

Наибольшая общая подпоследовательность (НОП) двух последовательностей - это максимальная по длине подпоследовательность, которую можно получить вычеркиванием некоторых элеменнтов из первой и из второй последовательности.

_Задача._ Даны две последовательности $a$ и $b$. Найти НОП для этих последовательностей.

_Решение._ Пусть $d p [i][j]$ - длина НОП для первых $i$ элементов последовательности $a$ и первых $j$ элементов последовательности $b$. Обозначим $n = abs(a), space m = abs(b)$.

+ Если $a[i] = b[j]$, то $d p [i][j] = d p [i-1][j-1] + 1$ (если элементы совпали, то мы берём данный элемент в НОП).

+ Иначе, как минимум один из элементов $a[i]$ или $b[j]$ не входит в НОП. Тогда $d p [i][j] = max(d p [i-1][j], d p [i][j-1])$.

Итак,

$
  d p [i][j] = cases(
    0 \, #[если $ i dot j = 0$],
    d p [i-1][j-1] + 1 \, space #[если $a[i] = b[j]$],
    max(d p [i-1][j], d p [i][j-1]) \, space #[если $a[i] != b[j]$]
  )
$

Длина НОП равна $d p [n-1][m-1]$. Для восстановления ответа поднимаемся по таблице $d p$ в обратном порядке по следующему алгоритму:

+ Если $a[i] = b[j]$, то добавляем этот элемент в НОП и переходим к $d p [i-1][j-1]$.
+ Иначе, переходим к $d p [i-1][j]$ или $d p [i][j-1]$, а точнее к тому из них, который имеет большее значение.


Сложность нахождения длины НОП по времени равна $Theta(n dot m)$. Для восстановления ответа потребуется ещё $O(n + m)$ времени.


